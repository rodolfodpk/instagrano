
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cache: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/rodolfodpk/instagrano/internal/cache/redis.go (60.0%)</option>
				
				<option value="file1">github.com/rodolfodpk/instagrano/internal/config/config.go (0.0%)</option>
				
				<option value="file2">github.com/rodolfodpk/instagrano/internal/domain/post.go (100.0%)</option>
				
				<option value="file3">github.com/rodolfodpk/instagrano/internal/domain/user.go (100.0%)</option>
				
				<option value="file4">github.com/rodolfodpk/instagrano/internal/handler/auth_handler.go (76.5%)</option>
				
				<option value="file5">github.com/rodolfodpk/instagrano/internal/handler/feed_handler.go (48.1%)</option>
				
				<option value="file6">github.com/rodolfodpk/instagrano/internal/handler/interaction_handler.go (75.0%)</option>
				
				<option value="file7">github.com/rodolfodpk/instagrano/internal/handler/post_handler.go (58.1%)</option>
				
				<option value="file8">github.com/rodolfodpk/instagrano/internal/logger/logger.go (0.0%)</option>
				
				<option value="file9">github.com/rodolfodpk/instagrano/internal/middleware/jwt.go (94.4%)</option>
				
				<option value="file10">github.com/rodolfodpk/instagrano/internal/middleware/logger.go (0.0%)</option>
				
				<option value="file11">github.com/rodolfodpk/instagrano/internal/pagination/cursor.go (70.6%)</option>
				
				<option value="file12">github.com/rodolfodpk/instagrano/internal/repository/postgres/connection.go (83.3%)</option>
				
				<option value="file13">github.com/rodolfodpk/instagrano/internal/repository/postgres/like_repository.go (89.5%)</option>
				
				<option value="file14">github.com/rodolfodpk/instagrano/internal/repository/postgres/post_repository.go (80.5%)</option>
				
				<option value="file15">github.com/rodolfodpk/instagrano/internal/repository/postgres/user_repository.go (100.0%)</option>
				
				<option value="file16">github.com/rodolfodpk/instagrano/internal/repository/s3/media_storage.go (0.0%)</option>
				
				<option value="file17">github.com/rodolfodpk/instagrano/internal/service/auth_service.go (95.0%)</option>
				
				<option value="file18">github.com/rodolfodpk/instagrano/internal/service/feed_service.go (70.5%)</option>
				
				<option value="file19">github.com/rodolfodpk/instagrano/internal/service/interaction_service.go (100.0%)</option>
				
				<option value="file20">github.com/rodolfodpk/instagrano/internal/service/post_service.go (93.3%)</option>
				
				<option value="file21">github.com/rodolfodpk/instagrano/tests/mock_storage.go (70.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cache

import (
        "context"
        "fmt"
        "time"

        "github.com/redis/go-redis/v9"
        "go.uber.org/zap"
)

// Cache interface for caching operations
type Cache interface {
        Get(ctx context.Context, key string) ([]byte, error)
        Set(ctx context.Context, key string, value []byte, ttl time.Duration) error
        Delete(ctx context.Context, key string) error
        Ping(ctx context.Context) error
}

// RedisCache implements the Cache interface using Redis
type RedisCache struct {
        client *redis.Client
        logger *zap.Logger
}

// NewRedisCache creates a new Redis cache client
func NewRedisCache(addr, password string, db int, logger *zap.Logger) (*RedisCache, error) <span class="cov10" title="39">{
        client := redis.NewClient(&amp;redis.Options{
                Addr:     addr,
                Password: password,
                DB:       db,
        })

        // Test connection
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := client.Ping(ctx).Err(); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to connect to redis: %w", err)
        }</span>

        <span class="cov9" title="38">logger.Info("redis client created successfully",
                zap.String("addr", addr),
                zap.Int("db", db),
        )

        return &amp;RedisCache{
                client: client,
                logger: logger,
        }, nil</span>
}

// Get retrieves a value from cache
func (r *RedisCache) Get(ctx context.Context, key string) ([]byte, error) <span class="cov6" title="8">{
        val, err := r.client.Get(ctx, key).Bytes()
        if err == redis.Nil </span><span class="cov5" title="7">{
                return nil, fmt.Errorf("cache miss: key not found")
        }</span>
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("redis get failed",
                        zap.String("key", key),
                        zap.Error(err),
                )
                return nil, err
        }</span>
        <span class="cov1" title="1">return val, nil</span>
}

// Set stores a value in cache with TTL
func (r *RedisCache) Set(ctx context.Context, key string, value []byte, ttl time.Duration) error <span class="cov5" title="7">{
        err := r.client.Set(ctx, key, value, ttl).Err()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("redis set failed",
                        zap.String("key", key),
                        zap.Duration("ttl", ttl),
                        zap.Error(err),
                )
                return err
        }</span>
        <span class="cov5" title="7">return nil</span>
}

// Delete removes a value from cache
func (r *RedisCache) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        err := r.client.Del(ctx, key).Err()
        if err != nil </span><span class="cov0" title="0">{
                r.logger.Error("redis delete failed",
                        zap.String("key", key),
                        zap.Error(err),
                )
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Ping checks if Redis is reachable
func (r *RedisCache) Ping(ctx context.Context) error <span class="cov0" title="0">{
        return r.client.Ping(ctx).Err()
}</span>

</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "os"
        "strconv"
        "time"

        "go.uber.org/zap"
)

type Config struct {
        DatabaseURL     string
        S3Endpoint      string
        S3Bucket        string
        JWTSecret       string
        Port            string
        LogLevel        string
        LogFormat       string
        DefaultPageSize int
        MaxPageSize     int
        RedisAddr       string
        RedisPassword   string
        RedisDB         int
        CacheTTL        time.Duration
}

func Load() *Config <span class="cov0" title="0">{
        return &amp;Config{
                DatabaseURL:     getEnv("DATABASE_URL", "postgres://postgres:postgres@localhost:5433/instagrano?sslmode=disable"),
                S3Endpoint:      getEnv("S3_ENDPOINT", "http://localhost:4566"),
                S3Bucket:        getEnv("S3_BUCKET", "instagrano-media"),
                JWTSecret:       getEnv("JWT_SECRET", "dev-secret"),
                Port:            getEnv("PORT", "3000"),
                LogLevel:        getEnv("LOG_LEVEL", "info"),
                LogFormat:       getEnv("LOG_FORMAT", "json"),
                DefaultPageSize: getEnvInt("DEFAULT_PAGE_SIZE", 20),
                MaxPageSize:     getEnvInt("MAX_PAGE_SIZE", 100),
                RedisAddr:       getEnv("REDIS_ADDR", "localhost:6379"),
                RedisPassword:   getEnv("REDIS_PASSWORD", ""),
                RedisDB:         getEnvInt("REDIS_DB", 0),
                CacheTTL:        getDurationEnv("CACHE_TTL", 5*time.Minute),
        }
}</span>

func (c *Config) GetZapLevel() zap.AtomicLevel <span class="cov0" title="0">{
        switch c.LogLevel </span>{
        case "debug":<span class="cov0" title="0">
                return zap.NewAtomicLevelAt(zap.DebugLevel)</span>
        case "info":<span class="cov0" title="0">
                return zap.NewAtomicLevelAt(zap.InfoLevel)</span>
        case "warn":<span class="cov0" title="0">
                return zap.NewAtomicLevelAt(zap.WarnLevel)</span>
        case "error":<span class="cov0" title="0">
                return zap.NewAtomicLevelAt(zap.ErrorLevel)</span>
        default:<span class="cov0" title="0">
                return zap.NewAtomicLevelAt(zap.InfoLevel)</span>
        }
}

func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value, ok := os.LookupEnv(key); ok </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvInt(key string, defaultValue int) int <span class="cov0" title="0">{
        if value, ok := os.LookupEnv(key); ok </span><span class="cov0" title="0">{
                if intValue, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                        return intValue
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getDurationEnv(key string, defaultValue time.Duration) time.Duration <span class="cov0" title="0">{
        if value, ok := os.LookupEnv(key); ok </span><span class="cov0" title="0">{
                if duration, err := time.ParseDuration(value); err == nil </span><span class="cov0" title="0">{
                        return duration
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package domain

import (
    "math"
    "time"
)

type Post struct {
    ID            uint      `json:"id"`
    UserID        uint      `json:"user_id"`
    Title         string    `json:"title"`
    Caption       string    `json:"caption"`
    MediaType     MediaType `json:"media_type"`
    MediaURL      string    `json:"media_url"`
    LikesCount    int       `json:"likes_count"`
    CommentsCount int       `json:"comments_count"`
    ViewsCount    int       `json:"views_count"`
    Score         float64   `json:"score"`
    CreatedAt     time.Time `json:"created_at"`
    UpdatedAt     time.Time `json:"updated_at"`
}

type MediaType string

const (
    MediaTypeImage MediaType = "image"
    MediaTypeVideo MediaType = "video"
)

const (
    LikeWeight    = 2.0
    CommentWeight = 3.0
    ViewWeight    = 0.1
    DecayRate     = 0.1
)

func (p *Post) CalculateScore() float64 <span class="cov10" title="10">{
    ageHours := time.Since(p.CreatedAt).Hours()
    engagementScore := float64(p.LikesCount)*LikeWeight +
        float64(p.CommentsCount)*CommentWeight +
        float64(p.ViewsCount)*ViewWeight
    timeDecay := math.Exp(-DecayRate * ageHours)
    return engagementScore * timeDecay
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package domain

import (
    "time"
    "golang.org/x/crypto/bcrypt"
)

type User struct {
    ID        uint      `json:"id"`
    Username  string    `json:"username"`
    Email     string    `json:"email"`
    Password  string    `json:"-"`
    CreatedAt time.Time `json:"created_at"`
    UpdatedAt time.Time `json:"updated_at"`
}

func (u *User) ValidatePassword(password string) error <span class="cov10" title="8">{
    return bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(password))
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package handler

import (
    "github.com/gofiber/fiber/v2"
    "github.com/rodolfodpk/instagrano/internal/service"
)

type AuthHandler struct {
    authService *service.AuthService
}

func NewAuthHandler(authService *service.AuthService) *AuthHandler <span class="cov10" title="6">{
    return &amp;AuthHandler{authService: authService}
}</span>

func (h *AuthHandler) Register(c *fiber.Ctx) error <span class="cov9" title="5">{
    var req struct {
        Username string `json:"username"`
        Email    string `json:"email"`
        Password string `json:"password"`
    }

    if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
        return c.Status(400).JSON(fiber.Map{"error": "invalid request"})
    }</span>

    <span class="cov9" title="5">user, err := h.authService.Register(req.Username, req.Email, req.Password)
    if err != nil </span><span class="cov0" title="0">{
        return c.Status(400).JSON(fiber.Map{"error": err.Error()})
    }</span>

    <span class="cov9" title="5">user.Password = ""
    return c.JSON(fiber.Map{"user": user})</span>
}

func (h *AuthHandler) Login(c *fiber.Ctx) error <span class="cov9" title="5">{
    var req struct {
        Email    string `json:"email"`
        Password string `json:"password"`
    }

    if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
        return c.Status(400).JSON(fiber.Map{"error": "invalid request"})
    }</span>

    <span class="cov9" title="5">user, token, err := h.authService.Login(req.Email, req.Password)
    if err != nil </span><span class="cov0" title="0">{
        return c.Status(401).JSON(fiber.Map{"error": "invalid credentials"})
    }</span>

    <span class="cov9" title="5">user.Password = ""
    return c.JSON(fiber.Map{"user": user, "token": token})</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handler

import (
        "strconv"

        "github.com/gofiber/fiber/v2"
        "github.com/rodolfodpk/instagrano/internal/config"
        "github.com/rodolfodpk/instagrano/internal/service"
        "go.uber.org/zap"
)

type FeedHandler struct {
        feedService *service.FeedService
        logger      *zap.Logger
        config      *config.Config
}

func NewFeedHandler(feedService *service.FeedService, cfg *config.Config) *FeedHandler <span class="cov10" title="6">{
        logger, _ := zap.NewProduction()
        return &amp;FeedHandler{
                feedService: feedService,
                logger:      logger,
                config:      cfg,
        }
}</span>

func (h *FeedHandler) GetFeed(c *fiber.Ctx) error <span class="cov1" title="1">{
        // Always use cursor-based pagination (more efficient)
        cursor := c.Query("cursor")
        return h.getFeedWithCursor(c, cursor)
}</span>

func (h *FeedHandler) getFeedWithCursor(c *fiber.Ctx, cursor string) error <span class="cov1" title="1">{
        limitStr := c.Query("limit", strconv.Itoa(h.config.DefaultPageSize))
        limit, err := strconv.Atoi(limitStr)
        if err != nil || limit &lt;= 0 || limit &gt; h.config.MaxPageSize </span><span class="cov1" title="1">{
                limit = h.config.DefaultPageSize
        }</span>

        <span class="cov1" title="1">h.logger.Info("getting feed with cursor",
                zap.String("cursor", cursor),
                zap.Int("limit", limit),
        )

        result, err := h.feedService.GetFeedWithCursor(limit, cursor)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to get feed with cursor", zap.Error(err))
                return c.Status(500).JSON(fiber.Map{"error": "failed to get feed"})
        }</span>

        <span class="cov1" title="1">h.logger.Info("feed retrieved successfully",
                zap.Int("posts_count", len(result.Posts)),
                zap.Bool("has_more", result.HasMore),
                zap.String("next_cursor", result.NextCursor),
        )

        return c.JSON(result)</span>
}

func (h *FeedHandler) getFeedWithPage(c *fiber.Ctx) error <span class="cov0" title="0">{
        page := c.QueryInt("page", 1)
        limitStr := c.Query("limit", strconv.Itoa(h.config.DefaultPageSize))
        limit, err := strconv.Atoi(limitStr)
        if err != nil || limit &lt;= 0 || limit &gt; h.config.MaxPageSize </span><span class="cov0" title="0">{
                limit = h.config.DefaultPageSize
        }</span>

        <span class="cov0" title="0">h.logger.Info("getting feed with page",
                zap.Int("page", page),
                zap.Int("limit", limit),
        )

        posts, err := h.feedService.GetFeed(page, limit)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.Error("failed to get feed with page", zap.Error(err))
                return c.Status(500).JSON(fiber.Map{"error": "failed to get feed"})
        }</span>

        <span class="cov0" title="0">h.logger.Info("feed retrieved successfully",
                zap.Int("posts_count", len(posts)),
                zap.Int("page", page),
        )

        return c.JSON(fiber.Map{"posts": posts, "page": page, "limit": limit})</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handler

import (
        "strconv"

        "github.com/gofiber/fiber/v2"
        "github.com/rodolfodpk/instagrano/internal/service"
)

type InteractionHandler struct {
        interactionService *service.InteractionService
}

func NewInteractionHandler(interactionService *service.InteractionService) *InteractionHandler <span class="cov10" title="6">{
        return &amp;InteractionHandler{interactionService: interactionService}
}</span>

func (h *InteractionHandler) LikePost(c *fiber.Ctx) error <span class="cov1" title="1">{
        userID := c.Locals("userID").(uint)
        postID, err := strconv.ParseUint(c.Params("id"), 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                return c.Status(400).JSON(fiber.Map{"error": "invalid post id"})
        }</span>

        <span class="cov1" title="1">err = h.interactionService.LikePost(userID, uint(postID))
        if err != nil </span><span class="cov0" title="0">{
                return c.Status(400).JSON(fiber.Map{"error": err.Error()})
        }</span>

        <span class="cov1" title="1">return c.JSON(fiber.Map{"message": "post liked"})</span>
}

func (h *InteractionHandler) CommentPost(c *fiber.Ctx) error <span class="cov1" title="1">{
        userID := c.Locals("userID").(uint)
        postID, err := strconv.ParseUint(c.Params("id"), 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                return c.Status(400).JSON(fiber.Map{"error": "invalid post id"})
        }</span>

        <span class="cov1" title="1">var req struct {
                Text string `json:"text"`
        }

        if err := c.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                return c.Status(400).JSON(fiber.Map{"error": "invalid request"})
        }</span>

        <span class="cov1" title="1">err = h.interactionService.CommentPost(userID, uint(postID), req.Text)
        if err != nil </span><span class="cov0" title="0">{
                return c.Status(400).JSON(fiber.Map{"error": err.Error()})
        }</span>

        <span class="cov1" title="1">return c.JSON(fiber.Map{"message": "comment added"})</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handler

import (
    "strconv"

    "github.com/gofiber/fiber/v2"
    "github.com/rodolfodpk/instagrano/internal/domain"
    "github.com/rodolfodpk/instagrano/internal/service"
)

type PostHandler struct {
    postService *service.PostService
}

func NewPostHandler(postService *service.PostService) *PostHandler <span class="cov10" title="6">{
    return &amp;PostHandler{postService: postService}
}</span>

func (h *PostHandler) CreatePost(c *fiber.Ctx) error <span class="cov6" title="3">{
    userID := c.Locals("userID").(uint)

    // Parse multipart form
    _, err := c.MultipartForm()
    if err != nil </span><span class="cov0" title="0">{
        return c.Status(400).JSON(fiber.Map{"error": "invalid form data"})
    }</span>

    <span class="cov6" title="3">title := c.FormValue("title")
    caption := c.FormValue("caption")
    mediaTypeStr := c.FormValue("media_type")

    if title == "" </span><span class="cov0" title="0">{
        return c.Status(400).JSON(fiber.Map{"error": "title is required"})
    }</span>

    <span class="cov6" title="3">mediaType := domain.MediaType(mediaTypeStr)
    if mediaType != domain.MediaTypeImage &amp;&amp; mediaType != domain.MediaTypeVideo </span><span class="cov0" title="0">{
        mediaType = domain.MediaTypeImage // default
    }</span>

    // Get uploaded file
    <span class="cov6" title="3">file, err := c.FormFile("media")
    if err != nil </span><span class="cov0" title="0">{
        return c.Status(400).JSON(fiber.Map{"error": "media file is required"})
    }</span>

    // Open file
    <span class="cov6" title="3">fileReader, err := file.Open()
    if err != nil </span><span class="cov0" title="0">{
        return c.Status(400).JSON(fiber.Map{"error": "failed to open file"})
    }</span>
    <span class="cov6" title="3">defer fileReader.Close()

    post, err := h.postService.CreatePost(userID, title, caption, mediaType, fileReader, file.Filename)
    if err != nil </span><span class="cov0" title="0">{
        return c.Status(400).JSON(fiber.Map{"error": err.Error()})
    }</span>

    <span class="cov6" title="3">return c.Status(201).JSON(post)</span>
}

func (h *PostHandler) GetPost(c *fiber.Ctx) error <span class="cov0" title="0">{
    id, err := strconv.ParseUint(c.Params("id"), 10, 32)
    if err != nil </span><span class="cov0" title="0">{
        return c.Status(400).JSON(fiber.Map{"error": "invalid post id"})
    }</span>

    <span class="cov0" title="0">post, err := h.postService.GetPost(uint(id))
    if err != nil </span><span class="cov0" title="0">{
        return c.Status(404).JSON(fiber.Map{"error": "post not found"})
    }</span>

    <span class="cov0" title="0">return c.JSON(post)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package logger

import (
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// Logger wraps zap.Logger for easier usage
type Logger struct {
        *zap.Logger
}

// New creates a new logger instance
func New(level zap.AtomicLevel, format string) *Logger <span class="cov0" title="0">{
        var config zap.Config

        if format == "console" </span><span class="cov0" title="0">{
                config = zap.NewDevelopmentConfig()
                config.Level = level
        }</span> else<span class="cov0" title="0"> {
                config = zap.NewProductionConfig()
                config.Level = level
                config.EncoderConfig.TimeKey = "timestamp"
                config.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
        }</span>

        <span class="cov0" title="0">logger, err := config.Build()
        if err != nil </span><span class="cov0" title="0">{
                panic("failed to initialize logger: " + err.Error())</span>
        }

        <span class="cov0" title="0">return &amp;Logger{Logger: logger}</span>
}

// WithRequestID adds request ID to logger context
func (l *Logger) WithRequestID(requestID string) *Logger <span class="cov0" title="0">{
        return &amp;Logger{Logger: l.Logger.With(zap.String("request_id", requestID))}
}</span>

// WithUserID adds user ID to logger context
func (l *Logger) WithUserID(userID uint) *Logger <span class="cov0" title="0">{
        return &amp;Logger{Logger: l.Logger.With(zap.Uint("user_id", userID))}
}</span>

// WithField adds a field to logger context
func (l *Logger) WithField(key string, value interface{}) *Logger <span class="cov0" title="0">{
        return &amp;Logger{Logger: l.Logger.With(zap.Any(key, value))}
}</span>

// WithFields adds multiple fields to logger context
func (l *Logger) WithFields(fields map[string]interface{}) *Logger <span class="cov0" title="0">{
        zapFields := make([]zap.Field, 0, len(fields))
        for k, v := range fields </span><span class="cov0" title="0">{
                zapFields = append(zapFields, zap.Any(k, v))
        }</span>
        <span class="cov0" title="0">return &amp;Logger{Logger: l.Logger.With(zapFields...)}</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package middleware

import (
        "fmt"
        "strings"

        "github.com/gofiber/fiber/v2"
        "github.com/golang-jwt/jwt/v5"
)

func JWT(jwtSecret string) fiber.Handler <span class="cov8" title="6">{
        return func(c *fiber.Ctx) error </span><span class="cov10" title="9">{
                authHeader := c.Get("Authorization")
                if authHeader == "" </span><span class="cov1" title="1">{
                        return c.Status(401).JSON(fiber.Map{"error": "missing token"})
                }</span>

                // Parse Authorization header properly
                <span class="cov9" title="8">parts := strings.Split(authHeader, " ")
                if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov1" title="1">{
                        return c.Status(401).JSON(fiber.Map{"error": "invalid authorization header format"})
                }</span>
                <span class="cov8" title="7">tokenString := parts[1]

                token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="6">{
                        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid signing method")
                        }</span>
                        <span class="cov8" title="6">return []byte(jwtSecret), nil</span>
                })

                <span class="cov8" title="7">if err != nil || !token.Valid </span><span class="cov1" title="1">{
                        return c.Status(401).JSON(fiber.Map{"error": "invalid token"})
                }</span>

                <span class="cov8" title="6">claims := token.Claims.(jwt.MapClaims)
                userID := uint(claims["user_id"].(float64))

                c.Locals("userID", userID)
                return c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package middleware

import (
        "crypto/rand"
        "encoding/hex"
        "time"

        "github.com/gofiber/fiber/v2"
        "github.com/rodolfodpk/instagrano/internal/logger"
        "go.uber.org/zap"
)

// RequestLogger creates a middleware for logging HTTP requests
func RequestLogger(log *logger.Logger) fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                start := time.Now()

                // Generate request ID
                requestID := generateRequestID()
                c.Locals("requestID", requestID)

                // Create logger with request context
                reqLogger := log.WithRequestID(requestID)

                // Log request start
                reqLogger.Info("request started",
                        zap.String("method", c.Method()),
                        zap.String("path", c.Path()),
                        zap.String("ip", c.IP()),
                        zap.String("user_agent", c.Get("User-Agent")),
                )

                // Process request
                err := c.Next()

                // Calculate duration
                duration := time.Since(start)

                // Get user ID if available
                var userID uint
                if uid := c.Locals("userID"); uid != nil </span><span class="cov0" title="0">{
                        userID = uid.(uint)
                }</span>

                // Log request completion
                <span class="cov0" title="0">fields := []zap.Field{
                        zap.String("method", c.Method()),
                        zap.String("path", c.Path()),
                        zap.Int("status", c.Response().StatusCode()),
                        zap.Duration("duration", duration),
                        zap.Int("response_size", len(c.Response().Body())),
                }

                if userID &gt; 0 </span><span class="cov0" title="0">{
                        fields = append(fields, zap.Uint("user_id", userID))
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        fields = append(fields, zap.Error(err))
                        reqLogger.Error("request completed with error", fields...)
                }</span> else<span class="cov0" title="0"> {
                        reqLogger.Info("request completed", fields...)
                }</span>

                <span class="cov0" title="0">return err</span>
        }
}

// generateRequestID creates a unique request ID
func generateRequestID() string <span class="cov0" title="0">{
        bytes := make([]byte, 8)
        rand.Read(bytes)
        return hex.EncodeToString(bytes)
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package pagination

import (
        "encoding/base64"
        "fmt"
        "strconv"
        "strings"
        "time"
)

// Cursor represents a pagination cursor
type Cursor struct {
        Timestamp time.Time
        ID        uint
}

// Encode encodes a cursor to a base64 string
func (c *Cursor) Encode() string <span class="cov8" title="1">{
        cursorStr := fmt.Sprintf("%d_%d", c.Timestamp.Unix(), c.ID)
        return base64.StdEncoding.EncodeToString([]byte(cursorStr))
}</span>

// Decode decodes a base64 string to a cursor
func DecodeCursor(cursorStr string) (*Cursor, error) <span class="cov8" title="1">{
        if cursorStr == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">decoded, err := base64.StdEncoding.DecodeString(cursorStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid cursor format: %w", err)
        }</span>

        <span class="cov8" title="1">parts := strings.Split(string(decoded), "_")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid cursor format")
        }</span>

        <span class="cov8" title="1">timestamp, err := strconv.ParseInt(parts[0], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid timestamp in cursor: %w", err)
        }</span>

        <span class="cov8" title="1">id, err := strconv.ParseUint(parts[1], 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid id in cursor: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;Cursor{
                Timestamp: time.Unix(timestamp, 0),
                ID:        uint(id),
        }, nil</span>
}

// FeedResult represents the result of a feed query with pagination
type FeedResult struct {
        Posts      []interface{} `json:"posts"`
        NextCursor string        `json:"next_cursor,omitempty"`
        HasMore    bool          `json:"has_more"`
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package postgres

import (
    "context"
    "database/sql"
    "fmt"
    "time"

    _ "github.com/jackc/pgx/v5/stdlib"
)

func Connect(databaseURL string) (*sql.DB, error) <span class="cov10" title="38">{
    db, err := sql.Open("pgx", databaseURL)
    if err != nil </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("failed to open database: %w", err)
    }</span>

    <span class="cov10" title="38">db.SetMaxOpenConns(25)
    db.SetMaxIdleConns(5)
    db.SetConnMaxLifetime(5 * time.Minute)
    db.SetConnMaxIdleTime(1 * time.Minute)

    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    if err := db.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("failed to ping database: %w", err)
    }</span>

    <span class="cov10" title="38">return db, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package postgres

import (
    "database/sql"
    "github.com/rodolfodpk/instagrano/internal/domain"
)

type LikeRepository interface {
        Create(like *domain.Like) error
        IncrementPostLikeCount(postID uint) error
        FindByPostID(postID uint) ([]*domain.Like, error)
}

type CommentRepository interface {
        Create(comment *domain.Comment) error
        IncrementPostCommentCount(postID uint) error
        FindByPostID(postID uint) ([]*domain.Comment, error)
}

type postgresLikeRepository struct {
    db *sql.DB
}

type postgresCommentRepository struct {
    db *sql.DB
}

func NewLikeRepository(db *sql.DB) LikeRepository <span class="cov10" title="16">{
    return &amp;postgresLikeRepository{db: db}
}</span>

func NewCommentRepository(db *sql.DB) CommentRepository <span class="cov10" title="16">{
    return &amp;postgresCommentRepository{db: db}
}</span>

func (r *postgresLikeRepository) Create(like *domain.Like) error <span class="cov8" title="9">{
    query := `INSERT INTO likes (user_id, post_id) VALUES ($1, $2) RETURNING id, created_at`
    return r.db.QueryRow(query, like.UserID, like.PostID).Scan(&amp;like.ID, &amp;like.CreatedAt)
}</span>

func (r *postgresLikeRepository) IncrementPostLikeCount(postID uint) error <span class="cov6" title="6">{
    query := `UPDATE posts SET likes_count = likes_count + 1 WHERE id = $1`
    _, err := r.db.Exec(query, postID)
    return err
}</span>

func (r *postgresCommentRepository) Create(comment *domain.Comment) error <span class="cov7" title="8">{
    query := `INSERT INTO comments (user_id, post_id, text) VALUES ($1, $2, $3) RETURNING id, created_at`
    return r.db.QueryRow(query, comment.UserID, comment.PostID, comment.Text).Scan(&amp;comment.ID, &amp;comment.CreatedAt)
}</span>

func (r *postgresCommentRepository) IncrementPostCommentCount(postID uint) error <span class="cov7" title="7">{
        query := `UPDATE posts SET comments_count = comments_count + 1 WHERE id = $1`
        _, err := r.db.Exec(query, postID)
        return err
}</span>

func (r *postgresLikeRepository) FindByPostID(postID uint) ([]*domain.Like, error) <span class="cov4" title="3">{
        query := `SELECT id, user_id, post_id, created_at FROM likes WHERE post_id = $1 ORDER BY created_at DESC`
        rows, err := r.db.Query(query, postID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov4" title="3">defer rows.Close()

        var likes []*domain.Like
        for rows.Next() </span><span class="cov6" title="5">{
                like := &amp;domain.Like{}
                err := rows.Scan(&amp;like.ID, &amp;like.UserID, &amp;like.PostID, &amp;like.CreatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov6" title="5">likes = append(likes, like)</span>
        }
        <span class="cov4" title="3">return likes, nil</span>
}

func (r *postgresCommentRepository) FindByPostID(postID uint) ([]*domain.Comment, error) <span class="cov5" title="4">{
        query := `SELECT id, user_id, post_id, text, created_at FROM comments WHERE post_id = $1 ORDER BY created_at DESC`
        rows, err := r.db.Query(query, postID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov5" title="4">defer rows.Close()

        var comments []*domain.Comment
        for rows.Next() </span><span class="cov6" title="6">{
                comment := &amp;domain.Comment{}
                err := rows.Scan(&amp;comment.ID, &amp;comment.UserID, &amp;comment.PostID, &amp;comment.Text, &amp;comment.CreatedAt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov6" title="6">comments = append(comments, comment)</span>
        }
        <span class="cov5" title="4">return comments, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package postgres

import (
        "database/sql"
        "fmt"

        "github.com/rodolfodpk/instagrano/internal/domain"
        "github.com/rodolfodpk/instagrano/internal/pagination"
)

type PostRepository interface {
        Create(post *domain.Post) error
        FindByID(id uint) (*domain.Post, error)
        GetFeed(limit, offset int) ([]*domain.Post, error)
        GetFeedWithCursor(limit int, cursor *pagination.Cursor) ([]*domain.Post, error)
}

type postgresPostRepository struct {
        db *sql.DB
}

func NewPostRepository(db *sql.DB) PostRepository <span class="cov10" title="25">{
        return &amp;postgresPostRepository{db: db}
}</span>

func (r *postgresPostRepository) Create(post *domain.Post) error <span class="cov6" title="7">{
        query := `
                INSERT INTO posts (user_id, title, caption, media_type, media_url)
                VALUES ($1, $2, $3, $4, $5)
                RETURNING id, created_at, updated_at`
        return r.db.QueryRow(query, post.UserID, post.Title, post.Caption,
                post.MediaType, post.MediaURL).
                Scan(&amp;post.ID, &amp;post.CreatedAt, &amp;post.UpdatedAt)
}</span>

func (r *postgresPostRepository) FindByID(id uint) (*domain.Post, error) <span class="cov7" title="10">{
        post := &amp;domain.Post{}
        query := `
                SELECT id, user_id, title, caption, media_type, media_url,
                           likes_count, comments_count, views_count, created_at, updated_at
                FROM posts WHERE id = $1`
        err := r.db.QueryRow(query, id).Scan(
                &amp;post.ID, &amp;post.UserID, &amp;post.Title, &amp;post.Caption, &amp;post.MediaType,
                &amp;post.MediaURL, &amp;post.LikesCount, &amp;post.CommentsCount, &amp;post.ViewsCount,
                &amp;post.CreatedAt, &amp;post.UpdatedAt,
        )
        if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("post with id %d not found", id)
        }</span>
        <span class="cov7" title="9">return post, err</span>
}

func (r *postgresPostRepository) GetFeed(limit, offset int) ([]*domain.Post, error) <span class="cov1" title="1">{
        query := `
                SELECT id, user_id, title, caption, media_type, media_url,
                           likes_count, comments_count, views_count, created_at, updated_at
                FROM posts ORDER BY created_at DESC LIMIT $1 OFFSET $2`
        rows, err := r.db.Query(query, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        var posts []*domain.Post
        for rows.Next() </span><span class="cov0" title="0">{
                post := &amp;domain.Post{}
                err := rows.Scan(
                        &amp;post.ID, &amp;post.UserID, &amp;post.Title, &amp;post.Caption, &amp;post.MediaType,
                        &amp;post.MediaURL, &amp;post.LikesCount, &amp;post.CommentsCount, &amp;post.ViewsCount,
                        &amp;post.CreatedAt, &amp;post.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">posts = append(posts, post)</span>
        }
        <span class="cov1" title="1">return posts, nil</span>
}

func (r *postgresPostRepository) GetFeedWithCursor(limit int, cursor *pagination.Cursor) ([]*domain.Post, error) <span class="cov6" title="7">{
        var query string
        var args []interface{}

        if cursor == nil </span><span class="cov6" title="6">{
                // First page - no cursor
                query = `
                        SELECT id, user_id, title, caption, media_type, media_url,
                                   likes_count, comments_count, views_count, created_at, updated_at
                        FROM posts 
                        ORDER BY created_at DESC, id DESC 
                        LIMIT $1`
                args = []interface{}{limit}
        }</span> else<span class="cov1" title="1"> {
                // Subsequent pages - use cursor
                query = `
                        SELECT id, user_id, title, caption, media_type, media_url,
                                   likes_count, comments_count, views_count, created_at, updated_at
                        FROM posts 
                        WHERE (created_at &lt; $2) OR (created_at = $2 AND id &lt; $3)
                        ORDER BY created_at DESC, id DESC 
                        LIMIT $1`
                args = []interface{}{limit, cursor.Timestamp, cursor.ID}
        }</span>

        <span class="cov6" title="7">rows, err := r.db.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query feed with cursor: %w", err)
        }</span>
        <span class="cov6" title="7">defer rows.Close()

        var posts []*domain.Post
        for rows.Next() </span><span class="cov7" title="10">{
                post := &amp;domain.Post{}
                err := rows.Scan(
                        &amp;post.ID, &amp;post.UserID, &amp;post.Title, &amp;post.Caption, &amp;post.MediaType,
                        &amp;post.MediaURL, &amp;post.LikesCount, &amp;post.CommentsCount, &amp;post.ViewsCount,
                        &amp;post.CreatedAt, &amp;post.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan post: %w", err)
                }</span>
                <span class="cov7" title="10">posts = append(posts, post)</span>
        }
        <span class="cov6" title="7">return posts, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package postgres

import (
    "database/sql"
    "github.com/rodolfodpk/instagrano/internal/domain"
)

type UserRepository interface {
    Create(user *domain.User) error
    FindByEmail(email string) (*domain.User, error)
}

type postgresUserRepository struct {
    db *sql.DB
}

func NewUserRepository(db *sql.DB) UserRepository <span class="cov10" title="14">{
    return &amp;postgresUserRepository{db: db}
}</span>

func (r *postgresUserRepository) Create(user *domain.User) error <span class="cov9" title="13">{
    query := `
        INSERT INTO users (username, email, password)
        VALUES ($1, $2, $3)
        RETURNING id, created_at, updated_at`
    return r.db.QueryRow(query, user.Username, user.Email, user.Password).
        Scan(&amp;user.ID, &amp;user.CreatedAt, &amp;user.UpdatedAt)
}</span>

func (r *postgresUserRepository) FindByEmail(email string) (*domain.User, error) <span class="cov8" title="9">{
    user := &amp;domain.User{}
    query := `SELECT id, username, email, password, created_at, updated_at FROM users WHERE email = $1`
    err := r.db.QueryRow(query, email).Scan(
        &amp;user.ID, &amp;user.Username, &amp;user.Email, &amp;user.Password,
        &amp;user.CreatedAt, &amp;user.UpdatedAt,
    )
    return user, err
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package s3

import (
        "bytes"
        "fmt"
        "io"
        "time"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/credentials"
        "github.com/aws/aws-sdk-go/aws/session"
        "github.com/aws/aws-sdk-go/service/s3"
        "go.uber.org/zap"
)

type MediaStorage interface {
        Upload(file io.Reader, filename string, contentType string) (string, error)
        GetURL(key string) string
}

type localStackS3Storage struct {
        s3Client *s3.S3
        bucket   string
        endpoint string
        logger   *zap.Logger
}

func NewMediaStorage(endpoint, region, bucket string) (MediaStorage, error) <span class="cov0" title="0">{
        logger, _ := zap.NewProduction()
        defer logger.Sync()

        logger.Info("initializing s3 storage",
                zap.String("endpoint", endpoint),
                zap.String("region", region),
                zap.String("bucket", bucket),
        )

        sess, err := session.NewSession(&amp;aws.Config{
                Region:           aws.String(region),
                Endpoint:         aws.String(endpoint),
                Credentials:      credentials.NewStaticCredentials("test", "test", ""),
                S3ForcePathStyle: aws.Bool(true), // Important for LocalStack
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create aws session", zap.Error(err))
                return nil, fmt.Errorf("failed to create AWS session: %w", err)
        }</span>

        <span class="cov0" title="0">client := s3.New(sess)

        // Skip bucket existence check for now - just log and proceed
        logger.Info("s3 client initialized", zap.String("bucket", bucket))

        return &amp;localStackS3Storage{
                s3Client: client,
                bucket:   bucket,
                endpoint: endpoint,
                logger:   logger,
        }, nil</span>
}

func (s *localStackS3Storage) Upload(file io.Reader, filename string, contentType string) (string, error) <span class="cov0" title="0">{
        key := fmt.Sprintf("posts/%d-%s", time.Now().Unix(), filename)
        s.logger.Info("uploading file to s3",
                zap.String("bucket", s.bucket),
                zap.String("key", key),
                zap.String("content_type", contentType),
                zap.String("filename", filename),
        )

        // Read the file content into bytes
        fileBytes, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to read file", zap.Error(err))
                return "", fmt.Errorf("failed to read file: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = s.s3Client.PutObject(&amp;s3.PutObjectInput{
                Bucket:      aws.String(s.bucket),
                Key:         aws.String(key),
                Body:        bytes.NewReader(fileBytes),
                ContentType: aws.String(contentType),
        })

        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("s3 upload failed",
                        zap.String("key", key),
                        zap.Error(err),
                )
                return "", err
        }</span>

        <span class="cov0" title="0">s.logger.Info("s3 upload successful",
                zap.String("key", key),
                zap.Int("size_bytes", len(fileBytes)),
        )
        return key, nil</span>
}

func (s *localStackS3Storage) GetURL(key string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s/%s/%s", s.endpoint, s.bucket, key)
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package service

import (
    "errors"
    "time"
    "github.com/golang-jwt/jwt/v5"
    "github.com/rodolfodpk/instagrano/internal/domain"
    "github.com/rodolfodpk/instagrano/internal/repository/postgres"
    "golang.org/x/crypto/bcrypt"
)

var (
    ErrInvalidInput       = errors.New("invalid input")
    ErrInvalidCredentials = errors.New("invalid credentials")
)

type AuthService struct {
    userRepo  postgres.UserRepository
    jwtSecret string
}

func NewAuthService(userRepo postgres.UserRepository, jwtSecret string) *AuthService <span class="cov9" title="14">{
    return &amp;AuthService{
        userRepo:  userRepo,
        jwtSecret: jwtSecret,
    }
}</span>

func (s *AuthService) Register(username, email, password string) (*domain.User, error) <span class="cov10" title="16">{
    if username == "" || email == "" || password == "" </span><span class="cov4" title="3">{
        return nil, ErrInvalidInput
    }</span>

    <span class="cov9" title="13">hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    if err != nil </span><span class="cov0" title="0">{
        return nil, err
    }</span>

    <span class="cov9" title="13">user := &amp;domain.User{
        Username: username,
        Email:    email,
        Password: string(hashedPassword),
    }

    if err := s.userRepo.Create(user); err != nil </span><span class="cov3" title="2">{
        return nil, err
    }</span>

    <span class="cov8" title="11">return user, nil</span>
}

func (s *AuthService) Login(email, password string) (*domain.User, string, error) <span class="cov8" title="9">{
    user, err := s.userRepo.FindByEmail(email)
    if err != nil </span><span class="cov1" title="1">{
        return nil, "", ErrInvalidCredentials
    }</span>

    <span class="cov7" title="8">if err := user.ValidatePassword(password); err != nil </span><span class="cov1" title="1">{
        return nil, "", ErrInvalidCredentials
    }</span>

    <span class="cov7" title="7">token, err := s.GenerateJWT(user.ID)
    return user, token, err</span>
}

func (s *AuthService) GenerateJWT(userID uint) (string, error) <span class="cov7" title="7">{
    claims := jwt.MapClaims{
        "user_id": userID,
        "exp":     time.Now().Add(24 * time.Hour).Unix(),
    }
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString([]byte(s.jwtSecret))
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package service

import (
        "context"
        "encoding/json"
        "fmt"
        "sort"
        "time"

        "github.com/rodolfodpk/instagrano/internal/cache"
        "github.com/rodolfodpk/instagrano/internal/domain"
        "github.com/rodolfodpk/instagrano/internal/pagination"
        "github.com/rodolfodpk/instagrano/internal/repository/postgres"
        "go.uber.org/zap"
)

type FeedService struct {
        postRepo postgres.PostRepository
        cache    cache.Cache
        cacheTTL time.Duration
        logger   *zap.Logger
}

func NewFeedService(postRepo postgres.PostRepository, cache cache.Cache, cacheTTL time.Duration) *FeedService <span class="cov10" title="11">{
        logger, _ := zap.NewProduction()
        return &amp;FeedService{
                postRepo: postRepo,
                cache:    cache,
                cacheTTL: cacheTTL,
                logger:   logger,
        }
}</span>

// GetFeedWithCursor implements cursor-based pagination with caching
func (s *FeedService) GetFeedWithCursor(limit int, cursor string) (*pagination.FeedResult, error) <span class="cov8" title="8">{
        start := time.Now()
        cacheKey := fmt.Sprintf("feed:cursor:%s:limit:%d", cursor, limit)
        ctx := context.Background()

        s.logger.Info("getting feed with cursor",
                zap.Int("limit", limit),
                zap.String("cursor", cursor),
                zap.String("cache_key", cacheKey),
        )

        // Try cache first
        if cached, err := s.cache.Get(ctx, cacheKey); err == nil </span><span class="cov1" title="1">{
                var result pagination.FeedResult
                if unmarshalErr := json.Unmarshal(cached, &amp;result); unmarshalErr == nil </span><span class="cov1" title="1">{
                        s.logger.Info("cache hit",
                                zap.String("cache_key", cacheKey),
                                zap.Duration("duration", time.Since(start)),
                        )
                        return &amp;result, nil
                }</span>
        }

        // Cache miss - fetch from database
        <span class="cov8" title="7">s.logger.Info("cache miss - fetching from database",
                zap.String("cache_key", cacheKey),
        )

        result, err := s.getFeedFromDatabase(limit, cursor)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Store in cache (best effort - don't fail if cache set fails)
        <span class="cov8" title="7">if data, marshalErr := json.Marshal(result); marshalErr == nil </span><span class="cov8" title="7">{
                if setErr := s.cache.Set(ctx, cacheKey, data, s.cacheTTL); setErr != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("failed to cache result",
                                zap.String("cache_key", cacheKey),
                                zap.Error(setErr),
                        )
                }</span> else<span class="cov8" title="7"> {
                        s.logger.Info("cached result",
                                zap.String("cache_key", cacheKey),
                                zap.Duration("ttl", s.cacheTTL),
                        )
                }</span>
        }

        <span class="cov8" title="7">s.logger.Info("feed retrieved successfully",
                zap.Int("posts_count", len(result.Posts)),
                zap.Bool("has_more", result.HasMore),
                zap.Duration("duration", time.Since(start)),
        )

        return result, nil</span>
}

// getFeedFromDatabase fetches feed from the database (extracted for caching logic)
func (s *FeedService) getFeedFromDatabase(limit int, cursor string) (*pagination.FeedResult, error) <span class="cov8" title="7">{
        // Decode cursor if provided
        var cursorObj *pagination.Cursor
        var err error
        if cursor != "" </span><span class="cov1" title="1">{
                cursorObj, err = pagination.DecodeCursor(cursor)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Error("failed to decode cursor", zap.Error(err))
                        return nil, err
                }</span>
        }

        // Get posts with cursor-based pagination
        <span class="cov8" title="7">posts, err := s.postRepo.GetFeedWithCursor(limit+1, cursorObj) // +1 to check if there are more
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to get feed from repository", zap.Error(err))
                return nil, err
        }</span>

        // Calculate scores and sort
        <span class="cov8" title="7">for _, post := range posts </span><span class="cov9" title="10">{
                post.Score = post.CalculateScore()
        }</span>

        <span class="cov8" title="7">sort.Slice(posts, func(i, j int) bool </span><span class="cov7" title="6">{
                return posts[i].Score &gt; posts[j].Score
        }</span>)

        // Check if there are more posts
        <span class="cov8" title="7">hasMore := len(posts) &gt; limit
        if hasMore </span><span class="cov1" title="1">{
                posts = posts[:limit] // Remove the extra post
        }</span>

        // Generate next cursor
        <span class="cov8" title="7">var nextCursor string
        if hasMore &amp;&amp; len(posts) &gt; 0 </span><span class="cov1" title="1">{
                lastPost := posts[len(posts)-1]
                nextCursorObj := &amp;pagination.Cursor{
                        Timestamp: lastPost.CreatedAt,
                        ID:        lastPost.ID,
                }
                nextCursor = nextCursorObj.Encode()
        }</span>

        <span class="cov8" title="7">return &amp;pagination.FeedResult{
                Posts:      convertPostsToInterface(posts),
                NextCursor: nextCursor,
                HasMore:    hasMore,
        }, nil</span>
}

// GetFeed maintains backward compatibility with page-based pagination
func (s *FeedService) GetFeed(page, limit int) ([]*domain.Post, error) <span class="cov0" title="0">{
        s.logger.Info("getting feed with page-based pagination",
                zap.Int("page", page),
                zap.Int("limit", limit),
        )

        offset := (page - 1) * limit
        posts, err := s.postRepo.GetFeed(limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to get feed from repository", zap.Error(err))
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, post := range posts </span><span class="cov0" title="0">{
                post.Score = post.CalculateScore()
        }</span>

        <span class="cov0" title="0">sort.Slice(posts, func(i, j int) bool </span><span class="cov0" title="0">{
                return posts[i].Score &gt; posts[j].Score
        }</span>)

        <span class="cov0" title="0">s.logger.Info("feed retrieved successfully",
                zap.Int("posts_count", len(posts)),
        )

        return posts, nil</span>
}

// convertPostsToInterface converts []*domain.Post to []interface{}
func convertPostsToInterface(posts []*domain.Post) []interface{} <span class="cov8" title="7">{
        result := make([]interface{}, len(posts))
        for i, post := range posts </span><span class="cov9" title="9">{
                result[i] = post
        }</span>
        <span class="cov8" title="7">return result</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package service

import (
    "github.com/rodolfodpk/instagrano/internal/domain"
    "github.com/rodolfodpk/instagrano/internal/repository/postgres"
)

type InteractionService struct {
    likeRepo    postgres.LikeRepository
    commentRepo postgres.CommentRepository
}

func NewInteractionService(likeRepo postgres.LikeRepository, commentRepo postgres.CommentRepository) *InteractionService <span class="cov10" title="16">{
    return &amp;InteractionService{
        likeRepo:    likeRepo,
        commentRepo: commentRepo,
    }
}</span>

func (s *InteractionService) LikePost(userID, postID uint) error <span class="cov8" title="9">{
    like := &amp;domain.Like{
        UserID: userID,
        PostID: postID,
    }

    if err := s.likeRepo.Create(like); err != nil </span><span class="cov4" title="3">{
        return err
    }</span>

    <span class="cov6" title="6">return s.likeRepo.IncrementPostLikeCount(postID)</span>
}

func (s *InteractionService) CommentPost(userID, postID uint, text string) error <span class="cov7" title="8">{
    comment := &amp;domain.Comment{
        UserID: userID,
        PostID: postID,
        Text:   text,
    }

    if err := s.commentRepo.Create(comment); err != nil </span><span class="cov1" title="1">{
        return err
    }</span>

    <span class="cov7" title="7">return s.commentRepo.IncrementPostCommentCount(postID)</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package service

import (
        "fmt"
        "io"

        "github.com/rodolfodpk/instagrano/internal/domain"
        "github.com/rodolfodpk/instagrano/internal/repository/postgres"
        "github.com/rodolfodpk/instagrano/internal/repository/s3"
)

type PostService struct {
        postRepo     postgres.PostRepository
        mediaStorage s3.MediaStorage
}

func NewPostService(postRepo postgres.PostRepository, mediaStorage s3.MediaStorage) *PostService <span class="cov10" title="14">{
        return &amp;PostService{
                postRepo:     postRepo,
                mediaStorage: mediaStorage,
        }
}</span>

func (s *PostService) CreatePost(userID uint, title, caption string, mediaType domain.MediaType, file io.Reader, filename string) (*domain.Post, error) <span class="cov8" title="9">{
        if title == "" </span><span class="cov1" title="1">{
                return nil, ErrInvalidInput
        }</span>

        // Determine content type based on media type
        <span class="cov8" title="8">contentType := "image/jpeg"
        if mediaType == domain.MediaTypeVideo </span><span class="cov1" title="1">{
                contentType = "video/mp4"
        }</span>

        // Upload file to S3
        <span class="cov8" title="8">key, err := s.mediaStorage.Upload(file, filename, contentType)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to upload file to S3: %w", err)
        }</span>

        // Generate URL from S3 key
        <span class="cov7" title="7">mediaURL := s.mediaStorage.GetURL(key)

        post := &amp;domain.Post{
                UserID:    userID,
                Title:     title,
                Caption:   caption,
                MediaType: mediaType,
                MediaURL:  mediaURL,
        }

        if err := s.postRepo.Create(post); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="7">return post, nil</span>
}

func (s *PostService) GetPost(postID uint) (*domain.Post, error) <span class="cov3" title="2">{
        return s.postRepo.FindByID(postID)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package tests

import (
        "fmt"
        "io"
)

// MockMediaStorage implements s3.MediaStorage interface for testing
type MockMediaStorage struct {
        files map[string][]byte
}

// NewMockMediaStorage creates a new mock media storage
func NewMockMediaStorage() *MockMediaStorage <span class="cov10" title="13">{
        return &amp;MockMediaStorage{
                files: make(map[string][]byte),
        }
}</span>

// Upload simulates file upload to S3
func (m *MockMediaStorage) Upload(file io.Reader, filename, contentType string) (string, error) <span class="cov7" title="7">{
        // Read file content
        content, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read file: %w", err)
        }</span>

        // Generate a mock S3 key
        <span class="cov7" title="7">key := fmt.Sprintf("mock-s3/%s", filename)
        
        // Store in memory
        m.files[key] = content
        
        return key, nil</span>
}

// GetURL returns a mock URL for the given key
func (m *MockMediaStorage) GetURL(key string) string <span class="cov7" title="7">{
        return fmt.Sprintf("http://mock-s3.example.com/%s", key)
}</span>

// GetFile returns the stored file content (for testing)
func (m *MockMediaStorage) GetFile(key string) ([]byte, bool) <span class="cov0" title="0">{
        content, exists := m.files[key]
        return content, exists
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
